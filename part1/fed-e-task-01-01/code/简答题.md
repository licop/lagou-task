## 简答题

#### 谈谈你是如何理解 JS 异步编程的，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？

**答:**

## 如何理解 JS 异步编程

Javascript 采用**单线程**模式工作,即 JS 执行环境中负责执行代码的线程只有一个。

单线程是必要的，也是 javascript 这门语言的基石，原因之一在其最初也是最主要的执行环境——浏览器中，我们需要进行各种各样的 dom 操作。试想一下 如果 javascript 是多线程的，那么当两个线程同时对 dom 进行一项操作，例如一个向其添加事件，而另一个删除了这个 dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript 选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。

**单线程**的模式的优点是更安全，更简单，缺点是如果遇到特别耗时的任务后面的任务都要排队等待任务结束。

程序的执行顺序与程序的编码顺序一致，在单线程模式下大多数任务都会以**同步模式**执行

不同于同步模式，异步模式的 Api 不会等待这个任务的结束才开始下一个任务，耗时操作开始过后就立即往后执行下一个任务，耗时操作的后续逻辑一般会通过回调函数的方式定义，耗时任务完成后会自动执行传入的回调函数。

## EventLoop、消息队列都是做什么的

- JS 引擎线程会维护一个**调用栈**，同步代码会依次加入到**调用栈**中依次执行并出栈。
- JS 引擎线程遇到异步函数（网络请求、计时器、DOM 事件监听等），会将异步函数交给相应的 Webapi，而继续执行后面的任务。
- Webapi 会在条件满足的时候，将异步对应的回调加入到**消息队列**中，等待执行。
- **调用栈**为空时，JS 引擎线程会去取**消息队列**中的回调函数（如果有的话），并加入到**调用栈**中执行。
- 完成后出栈，**调用栈**再次为空，重复上面的操作，这就是**事件循环(event loop)**

## 宏任务，微任务

采纳 JS 引擎的术语，我们把宿主发起的任务称为**宏观任务**，把 JavaScript 引擎发起的任务称为**微观任务**。

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。

我们只需记住当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

- 常见宏任务包括：setTimeout，setInterval，requestAnimationFrame
- 常见微任务包括：Promise.then .catch .finally，process.nextTick，MutationObserver
